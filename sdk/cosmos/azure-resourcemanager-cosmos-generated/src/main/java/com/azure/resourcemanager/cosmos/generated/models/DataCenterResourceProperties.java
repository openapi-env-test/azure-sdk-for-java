// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.cosmos.generated.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.util.List;

/** Properties of a managed Cassandra data center. */
@Fluent
public final class DataCenterResourceProperties {
    @JsonIgnore private final ClientLogger logger = new ClientLogger(DataCenterResourceProperties.class);

    /*
     * The status of the resource at the time the operation was called.
     */
    @JsonProperty(value = "provisioningState")
    private ManagedCassandraProvisioningState provisioningState;

    /*
     * The region this data center should be created in.
     */
    @JsonProperty(value = "dataCenterLocation")
    private String dataCenterLocation;

    /*
     * Resource id of a subnet the nodes in this data center should have their
     * network interfaces connected to. The subnet must be in the same region
     * specified in 'dataCenterLocation' and must be able to route to the
     * subnet specified in the cluster's 'delegatedManagementSubnetId'
     * property. This resource id will be of the form
     * '/subscriptions/<subscription id>/resourceGroups/<resource
     * group>/providers/Microsoft.Network/virtualNetworks/<virtual
     * network>/subnets/<subnet>'.
     */
    @JsonProperty(value = "delegatedSubnetId")
    private String delegatedSubnetId;

    /*
     * The number of nodes the data center should have. This is the desired
     * number. After it is set, it may take some time for the data center to be
     * scaled to match. To monitor the number of nodes and their status, use
     * the fetchNodeStatus method on the cluster.
     */
    @JsonProperty(value = "nodeCount")
    private Integer nodeCount;

    /*
     * IP addresses for seed nodes in this data center. This is for reference.
     * Generally you will want to use the seedNodes property on the cluster,
     * which aggregates the seed nodes from all data centers in the cluster.
     */
    @JsonProperty(value = "seedNodes", access = JsonProperty.Access.WRITE_ONLY)
    private List<SeedNode> seedNodes;

    /*
     * A fragment of a cassandra.yaml configuration file to be included in the
     * cassandra.yaml for all nodes in this data center. The fragment should be
     * Base64 encoded, and only a subset of keys are allowed.
     */
    @JsonProperty(value = "base64EncodedCassandraYamlFragment")
    private String base64EncodedCassandraYamlFragment;

    /**
     * Get the provisioningState property: The status of the resource at the time the operation was called.
     *
     * @return the provisioningState value.
     */
    public ManagedCassandraProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Set the provisioningState property: The status of the resource at the time the operation was called.
     *
     * @param provisioningState the provisioningState value to set.
     * @return the DataCenterResourceProperties object itself.
     */
    public DataCenterResourceProperties withProvisioningState(ManagedCassandraProvisioningState provisioningState) {
        this.provisioningState = provisioningState;
        return this;
    }

    /**
     * Get the dataCenterLocation property: The region this data center should be created in.
     *
     * @return the dataCenterLocation value.
     */
    public String dataCenterLocation() {
        return this.dataCenterLocation;
    }

    /**
     * Set the dataCenterLocation property: The region this data center should be created in.
     *
     * @param dataCenterLocation the dataCenterLocation value to set.
     * @return the DataCenterResourceProperties object itself.
     */
    public DataCenterResourceProperties withDataCenterLocation(String dataCenterLocation) {
        this.dataCenterLocation = dataCenterLocation;
        return this;
    }

    /**
     * Get the delegatedSubnetId property: Resource id of a subnet the nodes in this data center should have their
     * network interfaces connected to. The subnet must be in the same region specified in 'dataCenterLocation' and must
     * be able to route to the subnet specified in the cluster's 'delegatedManagementSubnetId' property. This resource
     * id will be of the form '/subscriptions/&lt;subscription id&gt;/resourceGroups/&lt;resource
     * group&gt;/providers/Microsoft.Network/virtualNetworks/&lt;virtual network&gt;/subnets/&lt;subnet&gt;'.
     *
     * @return the delegatedSubnetId value.
     */
    public String delegatedSubnetId() {
        return this.delegatedSubnetId;
    }

    /**
     * Set the delegatedSubnetId property: Resource id of a subnet the nodes in this data center should have their
     * network interfaces connected to. The subnet must be in the same region specified in 'dataCenterLocation' and must
     * be able to route to the subnet specified in the cluster's 'delegatedManagementSubnetId' property. This resource
     * id will be of the form '/subscriptions/&lt;subscription id&gt;/resourceGroups/&lt;resource
     * group&gt;/providers/Microsoft.Network/virtualNetworks/&lt;virtual network&gt;/subnets/&lt;subnet&gt;'.
     *
     * @param delegatedSubnetId the delegatedSubnetId value to set.
     * @return the DataCenterResourceProperties object itself.
     */
    public DataCenterResourceProperties withDelegatedSubnetId(String delegatedSubnetId) {
        this.delegatedSubnetId = delegatedSubnetId;
        return this;
    }

    /**
     * Get the nodeCount property: The number of nodes the data center should have. This is the desired number. After it
     * is set, it may take some time for the data center to be scaled to match. To monitor the number of nodes and their
     * status, use the fetchNodeStatus method on the cluster.
     *
     * @return the nodeCount value.
     */
    public Integer nodeCount() {
        return this.nodeCount;
    }

    /**
     * Set the nodeCount property: The number of nodes the data center should have. This is the desired number. After it
     * is set, it may take some time for the data center to be scaled to match. To monitor the number of nodes and their
     * status, use the fetchNodeStatus method on the cluster.
     *
     * @param nodeCount the nodeCount value to set.
     * @return the DataCenterResourceProperties object itself.
     */
    public DataCenterResourceProperties withNodeCount(Integer nodeCount) {
        this.nodeCount = nodeCount;
        return this;
    }

    /**
     * Get the seedNodes property: IP addresses for seed nodes in this data center. This is for reference. Generally you
     * will want to use the seedNodes property on the cluster, which aggregates the seed nodes from all data centers in
     * the cluster.
     *
     * @return the seedNodes value.
     */
    public List<SeedNode> seedNodes() {
        return this.seedNodes;
    }

    /**
     * Get the base64EncodedCassandraYamlFragment property: A fragment of a cassandra.yaml configuration file to be
     * included in the cassandra.yaml for all nodes in this data center. The fragment should be Base64 encoded, and only
     * a subset of keys are allowed.
     *
     * @return the base64EncodedCassandraYamlFragment value.
     */
    public String base64EncodedCassandraYamlFragment() {
        return this.base64EncodedCassandraYamlFragment;
    }

    /**
     * Set the base64EncodedCassandraYamlFragment property: A fragment of a cassandra.yaml configuration file to be
     * included in the cassandra.yaml for all nodes in this data center. The fragment should be Base64 encoded, and only
     * a subset of keys are allowed.
     *
     * @param base64EncodedCassandraYamlFragment the base64EncodedCassandraYamlFragment value to set.
     * @return the DataCenterResourceProperties object itself.
     */
    public DataCenterResourceProperties withBase64EncodedCassandraYamlFragment(
        String base64EncodedCassandraYamlFragment) {
        this.base64EncodedCassandraYamlFragment = base64EncodedCassandraYamlFragment;
        return this;
    }

    /**
     * Validates the instance.
     *
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (seedNodes() != null) {
            seedNodes().forEach(e -> e.validate());
        }
    }
}
